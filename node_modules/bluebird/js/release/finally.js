"use strict";
/**
 * Description
 * @method exports
 * @param {} Promise
 * @param {} tryConvertToPromise
 * @return PassThroughHandlerContext
 */
module.exports = function(Promise, tryConvertToPromise) {
var util = require("./util");
var CancellationError = Promise.CancellationError;
var errorObj = util.errorObj;

/**
 * Description
 * @method PassThroughHandlerContext
 * @param {} promise
 * @param {} type
 * @param {} handler
 * @return 
 */
function PassThroughHandlerContext(promise, type, handler) {
    this.promise = promise;
    this.type = type;
    this.handler = handler;
    this.called = false;
    this.cancelPromise = null;
}

/**
 * Description
 * @method isFinallyHandler
 * @return BinaryExpression
 */
PassThroughHandlerContext.prototype.isFinallyHandler = function() {
    return this.type === 0;
};

/**
 * Description
 * @method FinallyHandlerCancelReaction
 * @param {} finallyHandler
 * @return 
 */
function FinallyHandlerCancelReaction(finallyHandler) {
    this.finallyHandler = finallyHandler;
}

FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
    checkCancel(this.finallyHandler);
};

/**
 * Description
 * @method checkCancel
 * @param {} ctx
 * @param {} reason
 * @return Literal
 */
function checkCancel(ctx, reason) {
    if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
        } else {
            ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
    }
    return false;
}

/**
 * Description
 * @method succeed
 * @return CallExpression
 */
function succeed() {
    return finallyHandler.call(this, this.promise._target()._settledValue());
}
/**
 * Description
 * @method fail
 * @param {} reason
 * @return errorObj
 */
function fail(reason) {
    if (checkCancel(this, reason)) return;
    errorObj.e = reason;
    return errorObj;
}
/**
 * Description
 * @method finallyHandler
 * @param {} reasonOrValue
 * @return 
 */
function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler()
            ? handler.call(promise._boundValue())
            : handler.call(promise._boundValue(), reasonOrValue);
        if (ret !== undefined) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret, promise);
            if (maybePromise instanceof Promise) {
                if (this.cancelPromise != null) {
                    if (maybePromise.isCancelled()) {
                        var reason =
                            new CancellationError("late cancellation observer");
                        promise._attachExtraTrace(reason);
                        errorObj.e = reason;
                        return errorObj;
                    } else if (maybePromise.isPending()) {
                        maybePromise._attachCancellationCallback(
                            new FinallyHandlerCancelReaction(this));
                    }
                }
                return maybePromise._then(
                    succeed, fail, undefined, this, undefined);
            }
        }
    }

    if (promise.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
    } else {
        checkCancel(this);
        return reasonOrValue;
    }
}

Promise.prototype._passThrough = function(handler, type, success, fail) {
    if (typeof handler !== "function") return this.then();
    return this._then(success,
                      fail,
                      undefined,
                      new PassThroughHandlerContext(this, type, handler),
                      undefined);
};

Promise.prototype.lastly =
/**
 * Description
 * @param {} handler
 * @return CallExpression
 */
Promise.prototype["finally"] = function (handler) {
    return this._passThrough(handler,
                             0,
                             finallyHandler,
                             finallyHandler);
};

/**
 * Description
 * @method tap
 * @param {} handler
 * @return CallExpression
 */
Promise.prototype.tap = function (handler) {
    return this._passThrough(handler, 1, finallyHandler);
};

return PassThroughHandlerContext;
};
