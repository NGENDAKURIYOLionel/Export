(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){
/**
 * Description
 * @method s
 * @param {} o
 * @param {} u
 * @return MemberExpression
 */
function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
// AST walker module for Mozilla Parser API compatible trees

// A simple walk is one where you simply specify callbacks to be
// called on specific nodes. The last two arguments are optional. A
// simple use would be
//
//     walk.simple(myTree, {
//         Expression: function(node) { ... }
//     });
//
// to do something with all expressions. All Parser API node types
// can be used to identify node types, as well as Expression,
// Statement, and ScopeBody, which denote categories of nodes.
//
// The base argument can be used to pass a custom (recursive)
// walker, and state can be used to give this walked an initial
// state.

"use strict";

exports.__esModule = true;
exports.simple = simple;
exports.ancestor = ancestor;
exports.recursive = recursive;
exports.findNodeAt = findNodeAt;
exports.findNodeAround = findNodeAround;
exports.findNodeAfter = findNodeAfter;
exports.findNodeBefore = findNodeBefore;
exports.make = make;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Description
 * @method simple
 * @param {} node
 * @param {} visitors
 * @param {} base
 * @param {} state
 * @param {} override
 * @return 
 */
function simple(node, visitors, base, state, override) {
  if (!base) base = exports.base;(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state, override);
}

// An ancestor walk builds up an array of ancestor nodes (including
// the current node) and passes them to the callback as the state parameter.

/**
 * Description
 * @method ancestor
 * @param {} node
 * @param {} visitors
 * @param {} base
 * @param {} state
 * @return 
 */
function ancestor(node, visitors, base, state) {
  if (!base) base = exports.base;
  if (!state) state = [];(function c(node, st, override) {
    var type = override || node.type,
        found = visitors[type];
    if (node != st[st.length - 1]) {
      st = st.slice();
      st.push(node);
    }
    base[type](node, st, c);
    if (found) found(node, st);
  })(node, state);
}

// A recursive walk is one where your functions override the default
// walkers. They can modify and replace the state parameter that's
// threaded through the walk, and can opt how and whether to walk
// their child nodes (by calling their third argument on these
// nodes).

/**
 * Description
 * @method recursive
 * @param {} node
 * @param {} state
 * @param {} funcs
 * @param {} base
 * @param {} override
 * @return 
 */
function recursive(node, state, funcs, base, override) {
  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
    visitor[override || node.type](node, st, c);
  })(node, state, override);
}

/**
 * Description
 * @method makeTest
 * @param {} test
 * @return 
 */
function makeTest(test) {
  if (typeof test == "string") return function (type) {
    return type == test;
  };else if (!test) return function () {
    return true;
  };else return test;
}

/**
 * Description
 * @method Found
 * @param {} node
 * @param {} state
 * @return 
 */
var Found = function Found(node, state) {
  _classCallCheck(this, Found);

  this.node = node;this.state = state;
}

// Find a node with a given start, end, and type (all are optional,
// null can be used as wildcard). Returns a {node, state} object, or
// undefined when it doesn't find a matching node.
;

/**
 * Description
 * @method findNodeAt
 * @param {} node
 * @param {} start
 * @param {} end
 * @param {} test
 * @param {} base
 * @param {} state
 * @return 
 */
function findNodeAt(node, start, end, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
      if ((start == null || node.start == start) && (end == null || node.end == end) && test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}

// Find the innermost node of a given type that contains the given
// position. Interface similar to findNodeAt.

/**
 * Description
 * @method findNodeAround
 * @param {} node
 * @param {} pos
 * @param {} test
 * @param {} base
 * @param {} state
 * @return 
 */
function findNodeAround(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      var type = override || node.type;
      if (node.start > pos || node.end < pos) return;
      base[type](node, st, c);
      if (test(type, node)) throw new Found(node, st);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}

// Find the outermost matching node after a given position.

/**
 * Description
 * @method findNodeAfter
 * @param {} node
 * @param {} pos
 * @param {} test
 * @param {} base
 * @param {} state
 * @return 
 */
function findNodeAfter(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  try {
    ;(function c(node, st, override) {
      if (node.end < pos) return;
      var type = override || node.type;
      if (node.start >= pos && test(type, node)) throw new Found(node, st);
      base[type](node, st, c);
    })(node, state);
  } catch (e) {
    if (e instanceof Found) return e;
    throw e;
  }
}

// Find the outermost matching node before a given position.

/**
 * Description
 * @method findNodeBefore
 * @param {} node
 * @param {} pos
 * @param {} test
 * @param {} base
 * @param {} state
 * @return max
 */
function findNodeBefore(node, pos, test, base, state) {
  test = makeTest(test);
  if (!base) base = exports.base;
  var max = undefined;(function c(node, st, override) {
    if (node.start > pos) return;
    var type = override || node.type;
    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
    base[type](node, st, c);
  })(node, state);
  return max;
}

// Used to create a custom walker. Will fill in all missing node
// type properties with the defaults.

/**
 * Description
 * @method make
 * @param {} funcs
 * @param {} base
 * @return visitor
 */
function make(funcs, base) {
  if (!base) base = exports.base;
  var visitor = {};
  for (var type in base) visitor[type] = base[type];
  for (var type in funcs) visitor[type] = funcs[type];
  return visitor;
}

/**
 * Description
 * @method skipThrough
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
function skipThrough(node, st, c) {
  c(node, st);
}
/**
 * Description
 * @method ignore
 * @param {} _node
 * @param {} _st
 * @param {} _c
 * @return 
 */
function ignore(_node, _st, _c) {}

// Node walkers.

var base = {};

exports.base = base;
base.Program = 
/**
  * Description
  * @method BlockStatement
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.BlockStatement = function (node, st, c) {
  for (var i = 0; i < node.body.length; ++i) {
    c(node.body[i], st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = 
/**
  * Description
  * @method ParenthesizedExpression
  * @param {} node
  * @param {} st
  * @param {} c
  * @return CallExpression
  */
 base.ParenthesizedExpression = function (node, st, c) {
  return c(node.expression, st, "Expression");
};
/**
 * Description
 * @method IfStatement
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.IfStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) c(node.alternate, st, "Statement");
};
/**
 * Description
 * @method LabeledStatement
 * @param {} node
 * @param {} st
 * @param {} c
 * @return CallExpression
 */
base.LabeledStatement = function (node, st, c) {
  return c(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
/**
 * Description
 * @method WithStatement
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.WithStatement = function (node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
/**
 * Description
 * @method SwitchStatement
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.SwitchStatement = function (node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0; i < node.cases.length; ++i) {
    var cs = node.cases[i];
    if (cs.test) c(cs.test, st, "Expression");
    for (var j = 0; j < cs.consequent.length; ++j) {
      c(cs.consequent[j], st, "Statement");
    }
  }
};
base.ReturnStatement = 
/**
  * Description
  * @method YieldExpression
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.YieldExpression = function (node, st, c) {
  if (node.argument) c(node.argument, st, "Expression");
};
base.ThrowStatement = 
/**
  * Description
  * @method SpreadElement
  * @param {} node
  * @param {} st
  * @param {} c
  * @return CallExpression
  */
 base.SpreadElement = function (node, st, c) {
  return c(node.argument, st, "Expression");
};
/**
 * Description
 * @method TryStatement
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.TryStatement = function (node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) {
    c(node.handler.param, st, "Pattern");
    c(node.handler.body, st, "ScopeBody");
  }
  if (node.finalizer) c(node.finalizer, st, "Statement");
};
base.WhileStatement = 
/**
  * Description
  * @method DoWhileStatement
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.DoWhileStatement = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
/**
 * Description
 * @method ForStatement
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ForStatement = function (node, st, c) {
  if (node.init) c(node.init, st, "ForInit");
  if (node.test) c(node.test, st, "Expression");
  if (node.update) c(node.update, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInStatement = 
/**
  * Description
  * @method ForOfStatement
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.ForOfStatement = function (node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
/**
 * Description
 * @method ForInit
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ForInit = function (node, st, c) {
  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
};
base.DebuggerStatement = ignore;

/**
 * Description
 * @method FunctionDeclaration
 * @param {} node
 * @param {} st
 * @param {} c
 * @return CallExpression
 */
base.FunctionDeclaration = function (node, st, c) {
  return c(node, st, "Function");
};
/**
 * Description
 * @method VariableDeclaration
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.VariableDeclaration = function (node, st, c) {
  for (var i = 0; i < node.declarations.length; ++i) {
    c(node.declarations[i], st);
  }
};
/**
 * Description
 * @method VariableDeclarator
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.VariableDeclarator = function (node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) c(node.init, st, "Expression");
};

/**
 * Description
 * @method Function
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.Function = function (node, st, c) {
  if (node.id) c(node.id, st, "Pattern");
  for (var i = 0; i < node.params.length; i++) {
    c(node.params[i], st, "Pattern");
  }c(node.body, st, node.expression ? "ScopeExpression" : "ScopeBody");
};
// FIXME drop these node types in next major version
// (They are awkward, and in ES6 every block can be a scope.)
/**
 * Description
 * @method ScopeBody
 * @param {} node
 * @param {} st
 * @param {} c
 * @return CallExpression
 */
base.ScopeBody = function (node, st, c) {
  return c(node, st, "Statement");
};
/**
 * Description
 * @method ScopeExpression
 * @param {} node
 * @param {} st
 * @param {} c
 * @return CallExpression
 */
base.ScopeExpression = function (node, st, c) {
  return c(node, st, "Expression");
};

/**
 * Description
 * @method Pattern
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.Pattern = function (node, st, c) {
  if (node.type == "Identifier") c(node, st, "VariablePattern");else if (node.type == "MemberExpression") c(node, st, "MemberPattern");else c(node, st);
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
/**
 * Description
 * @method RestElement
 * @param {} node
 * @param {} st
 * @param {} c
 * @return CallExpression
 */
base.RestElement = function (node, st, c) {
  return c(node.argument, st, "Pattern");
};
/**
 * Description
 * @method ArrayPattern
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ArrayPattern = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Pattern");
  }
};
/**
 * Description
 * @method ObjectPattern
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ObjectPattern = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i].value, st, "Pattern");
  }
};

base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
/**
 * Description
 * @method ArrayExpression
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ArrayExpression = function (node, st, c) {
  for (var i = 0; i < node.elements.length; ++i) {
    var elt = node.elements[i];
    if (elt) c(elt, st, "Expression");
  }
};
/**
 * Description
 * @method ObjectExpression
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ObjectExpression = function (node, st, c) {
  for (var i = 0; i < node.properties.length; ++i) {
    c(node.properties[i], st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = 
/**
  * Description
  * @method TemplateLiteral
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.TemplateLiteral = function (node, st, c) {
  for (var i = 0; i < node.expressions.length; ++i) {
    c(node.expressions[i], st, "Expression");
  }
};
base.UnaryExpression = 
/**
  * Description
  * @method UpdateExpression
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.UpdateExpression = function (node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = 
/**
  * Description
  * @method LogicalExpression
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.LogicalExpression = function (node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.AssignmentExpression = 
/**
  * Description
  * @method AssignmentPattern
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.AssignmentPattern = function (node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
/**
 * Description
 * @method ConditionalExpression
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ConditionalExpression = function (node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = 
/**
  * Description
  * @method CallExpression
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.CallExpression = function (node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
    c(node.arguments[i], st, "Expression");
  }
};
/**
 * Description
 * @method MemberExpression
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.MemberExpression = function (node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) c(node.property, st, "Expression");
};
base.ExportNamedDeclaration = 
/**
  * Description
  * @method ExportDefaultDeclaration
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.ExportDefaultDeclaration = function (node, st, c) {
  if (node.declaration) c(node.declaration, st, node.type == "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  if (node.source) c(node.source, st, "Expression");
};
/**
 * Description
 * @method ExportAllDeclaration
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ExportAllDeclaration = function (node, st, c) {
  c(node.source, st, "Expression");
};
/**
 * Description
 * @method ImportDeclaration
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ImportDeclaration = function (node, st, c) {
  for (var i = 0; i < node.specifiers.length; i++) {
    c(node.specifiers[i], st);
  }c(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

/**
 * Description
 * @method TaggedTemplateExpression
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.TaggedTemplateExpression = function (node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st);
};
base.ClassDeclaration = 
/**
  * Description
  * @method ClassExpression
  * @param {} node
  * @param {} st
  * @param {} c
  * @return CallExpression
  */
 base.ClassExpression = function (node, st, c) {
  return c(node, st, "Class");
};
/**
 * Description
 * @method Class
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.Class = function (node, st, c) {
  if (node.id) c(node.id, st, "Pattern");
  if (node.superClass) c(node.superClass, st, "Expression");
  for (var i = 0; i < node.body.body.length; i++) {
    c(node.body.body[i], st);
  }
};
base.MethodDefinition = 
/**
  * Description
  * @method Property
  * @param {} node
  * @param {} st
  * @param {} c
  * @return 
  */
 base.Property = function (node, st, c) {
  if (node.computed) c(node.key, st, "Expression");
  c(node.value, st, "Expression");
};
/**
 * Description
 * @method ComprehensionExpression
 * @param {} node
 * @param {} st
 * @param {} c
 * @return 
 */
base.ComprehensionExpression = function (node, st, c) {
  for (var i = 0; i < node.blocks.length; i++) {
    c(node.blocks[i].right, st, "Expression");
  }c(node.body, st, "Expression");
};

},{}]},{},[1])(1)
});