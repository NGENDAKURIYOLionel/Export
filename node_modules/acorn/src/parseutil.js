import {types as tt} from "./tokentype"
import {Parser} from "./state"
import {lineBreak} from "./whitespace"

const pp = Parser.prototype

// ## Parser utilities

// Test whether a statement node is the string literal `"use strict"`.

/**
 * Description
 * @method isUseStrict
 * @param {} stmt
 * @return LogicalExpression
 */
pp.isUseStrict = function(stmt) {
  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
    stmt.expression.type === "Literal" &&
    stmt.expression.raw.slice(1, -1) === "use strict"
}

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

/**
 * Description
 * @method eat
 * @param {} type
 * @return 
 */
pp.eat = function(type) {
  if (this.type === type) {
    this.next()
    return true
  } else {
    return false
  }
}

// Tests whether parsed token is a contextual keyword.

/**
 * Description
 * @method isContextual
 * @param {} name
 * @return LogicalExpression
 */
pp.isContextual = function(name) {
  return this.type === tt.name && this.value === name
}

// Consumes contextual keyword if possible.

/**
 * Description
 * @method eatContextual
 * @param {} name
 * @return LogicalExpression
 */
pp.eatContextual = function(name) {
  return this.value === name && this.eat(tt.name)
}

// Asserts that following token is given contextual keyword.

/**
 * Description
 * @method expectContextual
 * @param {} name
 * @return 
 */
pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) this.unexpected()
}

// Test whether a semicolon can be inserted at the current position.

/**
 * Description
 * @method canInsertSemicolon
 * @return LogicalExpression
 */
pp.canInsertSemicolon = function() {
  return this.type === tt.eof ||
    this.type === tt.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}

/**
 * Description
 * @method insertSemicolon
 * @return 
 */
pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)
    return true
  }
}

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

/**
 * Description
 * @method semicolon
 * @return 
 */
pp.semicolon = function() {
  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()
}

/**
 * Description
 * @method afterTrailingComma
 * @param {} tokType
 * @return 
 */
pp.afterTrailingComma = function(tokType) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma)
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)
    this.next()
    return true
  }
}

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

/**
 * Description
 * @method expect
 * @param {} type
 * @return 
 */
pp.expect = function(type) {
  this.eat(type) || this.unexpected()
}

// Raise an unexpected token error.

/**
 * Description
 * @method unexpected
 * @param {} pos
 * @return 
 */
pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token")
}

/**
 * Description
 * @method checkPatternErrors
 * @param {} refDestructuringErrors
 * @param {} andThrow
 * @return 
 */
pp.checkPatternErrors = function(refDestructuringErrors, andThrow) {
  let pos = refDestructuringErrors && refDestructuringErrors.trailingComma
  if (!andThrow) return !!pos
  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns")
}

/**
 * Description
 * @method checkExpressionErrors
 * @param {} refDestructuringErrors
 * @param {} andThrow
 * @return 
 */
pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  let pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign
  if (!andThrow) return !!pos
  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns")
}
